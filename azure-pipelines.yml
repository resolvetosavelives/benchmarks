##
# Start with a minimal pipeline that you can customize to build and deploy your code.
# Add steps that build, run tests, deploy, and more:
# https://aka.ms/yaml
##

trigger:
  - main

parameters:
  - name: buildBaseImage
    displayName: Build Docker Base Image
    type: boolean
    default: false
  - name: containerRegistryServiceConnection
    displayName: Container Registry Service Connection
    type: string
    default: SC-IHRBENCHMARK-P-ACR
  - name: azureSubscription
    displayName: Azure Resource Manager Service Connection Name
    type: string
    default: SC-IHRBENCHMARK-P-WEU-RG01
    values:
      - SC-IHRBENCHMARK-P-WEU-RG01
      - SC-IHRBENCHMARK-T-WEU-RG01

# TODO: Parameterize these in the variable group
variables:
  - group: pipeline-variable-group
  - name: DOCKER_BUILDKIT
    value: 1
  - name: tag
    value: $(build.buildId)
  - name: appName
    value: benchmarks
  - name: containerRegistry
    value: ${{parameters.containerRegistryServiceConnection}}
  - name: containerRegistryDomain
    value: ihrbenchmarkwhoproduction.azurecr.io
  - name: imageName
    value: $(containerRegistryDomain)/$(appName):$(tag)
  - name: azureSubscription
    value: ${{parameters.azureSubscription}}
  - name: webAppName
    value: whoproduction-ihrbenchmark-app-service
  - name: resourceGroupName
    value: IHRBENCHMARK-P-WEU-RG01
  - name: isMain
    value: $[eq(variables['Build.SourceBranch'], 'refs/heads/main')]
  - name: buildBaseImage
    value: ${{ parameters.buildBaseImage }}

# Schedule builds trigger the base image build step.
schedules:
  - cron: "0 0 * * *"
    displayName: Daily midnight build for base image
    branches:
      include:
        - main

##
# the MS-provided ubuntu-20.04 image includes postgres
# full list of includes software:
# https://github.com/actions/virtual-environments/blob/main/images/linux/Ubuntu2004-README.md
pool:
  vmImage: ubuntu-20.04

stages:
  - stage: Test
    jobs:
      - job: Test
        displayName: Run CI Tests
        condition: ne(Build.reason, 'Schedule')
        steps:
          - task: UseRubyVersion@0
            inputs:
              versionSpec: ">= 3.0"
              addToPath: true
          - task: NodeTool@0
            inputs:
              versionSpec: "16.x"
          - script: |
              bin/bundle config set --local path vendor/bundle && \
              bin/bundle config set --local deployment true && \
              bin/bundle install
            displayName: bundle install
          - script: yarn install --frozen-lockfile --check-files
            displayName: yarn install
          - task: CmdLine@2
            displayName: prepare test db
            inputs:
              script: DATABASE_URL=$(DATABASE_URL) RAILS_ENV=test bin/bundle exec rake db:schema:load db:seed
          - task: CmdLine@2
            displayName: rake test:ci
            inputs:
              script: DATABASE_URL=$(DATABASE_URL) MINITEST_REPORTER=JUnitReporter bin/bundle exec rake test:ci
          - task: PublishTestResults@2
            condition: succeededOrFailed()
            inputs:
              codeCoverageTool: JUnit
              testRunTitle: Benchmarks ruby rspec test suite with in-browser
              testResultsFiles: "**/TEST-*.xml"

  - stage: Build
    condition: and(succeeded(), eq(variables.isMain, 'true'))
    displayName: Build and Push
    jobs:
      - job: BuildBase
        displayName: Build Base Image
        # Build the base image when the trigger reason was a scheduled build
        condition: and(succeeded(), or(eq(Build.reason, 'Schedule'), eq(variables.buildBaseImage, 'true')))
        steps:
          - task: Docker@2
            displayName: Docker login to ACR
            inputs:
              command: login
              containerRegistry: $(containerRegistry)
          - task: Docker@2
            displayName: Docker build base image
            inputs:
              command: build
              containerRegistry: $(containerRegistry)
              repository: benchmarks_builder
              buildContext: $(Build.Repository.LocalPath)
              Dockerfile: config/docker/builder/Dockerfile
              tags: latest
              arguments: "--no-cache"
          - task: Docker@2
            displayName: Docker push image to ACR
            inputs:
              command: push
              containerRegistry: $(containerRegistry)
              repository: benchmarks_builder
              tags: latest
      - job: Build
        displayName: Build Docker Image
        dependsOn: BuildBase
        condition: and(succeeded(), ne(Build.reason, 'Schedule'))
        steps:
          - task: Docker@2
            displayName: Docker login to ACR
            inputs:
              command: login
              containerRegistry: $(containerRegistry)
          - script: echo $(RAILS_MASTER_KEY) > config/master.key
            displayName: Write RAILS_MASTER_KEY to file config/master.key
          - task: Docker@2
            displayName: Docker build image
            inputs:
              command: build
              containerRegistry: $(containerRegistry)
              repository: $(appName)
              buildContext: $(Build.Repository.LocalPath)
              Dockerfile: config/docker/Dockerfile
              tags: latest
              arguments: "--secret id=RAILS_MASTER_KEY,src=config/master.key --no-cache"
          - script: rm config/master.key
            displayName: Delete RAILS_MASTER_KEY file config/master.key
      - job: Push
        dependsOn: Build
        displayName: Push to Container Registry
        steps:
          - task: Docker@2
            displayName: Docker push image to ACR
            inputs:
              command: push
              containerRegistry: $(containerRegistry)
              repository: $(appName)
              tags: latest
  - stage: Staging
    dependsOn: Build
    jobs:
      - job: Deploy
        displayName: Deploy to Staging
        steps:
          - task: AzureWebAppContainer@1
            inputs:
              azureSubscription: $(azureSubscription)
              appName: $(webAppName)
              imageName: $(imageName)
              deployToSlotOrASE: true
              ResourceGroupName: $(resourceGroupName)
              slotName: staging
  - stage: Production
    dependsOn: Staging
    jobs:
      - job: Promote
        displayName: Promote to production
        steps:
          - task: AzureAppServiceManage@0
            inputs:
              azureSubscription: $(azureSubscription)
              WebAppName: $(webAppName)
              ResourceGroupName: $(resourceGroupName)
              SourceSlot: staging
              SwapWithProduction: true
