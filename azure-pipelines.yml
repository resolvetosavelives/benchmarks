# Schedule builds trigger the base image build step.
schedules:
  - cron: "0 0 * * *"
    displayName: Daily midnight build for base image
    branches:
      include:
        - main

# These parameters with hardcoded values are here to show the manual link
# between the pipeline and the resource created manually by the WHO azure admin.
# My goal is to expose them here to avoid burying them deep in terraform or ENV.
# These are not expected to be changeable (it likely won't work)
parameters:
  - name: azureSubscription
    displayName: Azure Resource Manager Service Connection Name
    type: string
    default: SC-IHRBENCHMARK-P-WEU-RG01
  # Allow access to building the base image outside of the scheduled build.
  # This is useful when you change the base image and want to iterate on it.
  - name: buildBaseImage
    displayName: Build Docker Base Image
    type: boolean
    default: false

variables:
  # The variable group is created by terraform to hold pipeline info that is
  # generated by terraform and could potentially change on a future run.
  - group: pipeline-variable-group
  - name: DOCKER_BUILDKIT
    value: 1
  - name: tag
    value: $(build.buildId)
  - name: azureSubscription
    value: ${{parameters.azureSubscription}}
  - name: isMain
    value: $[eq(variables['Build.SourceBranch'], 'refs/heads/main')]
  - name: buildBaseImage
    value: ${{ parameters.buildBaseImage }}

resources:
  containers:
    - container: postgres
      image: postgres:14-alpine
      env:
        POSTGRES_DB: benchmarks_test
        POSTGRES_USER: postgres
        POSTGRES_PASSWORD: postgresPassword
      ports:
        - "5432:5432"

stages:
  - stage: Test
    variables:
      CI: true
      DATABASE_URL: postgres://postgres:postgresPassword@localhost:5432/benchmarks_test
      RAILS_ENV: test
    jobs:
      - job: Test
        displayName: Run CI Tests
        condition: ne(variables['Build.Reason'], 'Schedule')
        pool:
          # ubuntu-20.04 image includes most of what we need, cutting down on installs
          # https://github.com/actions/virtual-environments/blob/main/images/linux/Ubuntu2004-Readme.md
          vmImage: "ubuntu-20.04"
        services:
          postgres: postgres
        steps:
          - script: printenv
            displayName: printenv
          - task: UseRubyVersion@0
            inputs:
              versionSpec: ">= 3.0"
              addToPath: true
          - task: NodeTool@0
            inputs:
              versionSpec: "16.x"
          - script: |
              bin/bundle config set --local path vendor/bundle && \
              bin/bundle config set --local deployment true && \
              bin/bundle install
            displayName: bundle install
          - script: yarn install --frozen-lockfile --check-files
            displayName: yarn install
          - task: CmdLine@2
            displayName: prepare test db
            inputs:
              script: bin/bundle exec rake db:schema:load db:seed
          - task: CmdLine@2
            # precompile assets to avoid timeouts during capybara tests
            displayName: precompile assets
            inputs:
              script: bin/bundle exec rails assets:precompile
          - task: CmdLine@2
            displayName: rake spec:ci
            env:
              SPEC_OPTS: "--format progress --format RspecJunitFormatter --out tmp/rspec.xml"
            inputs:
              script: bin/bundle exec rake spec:ci
          - publish: $(System.DefaultWorkingDirectory)/tmp/capybara
            displayName: Publish Failure Screenshot
            artifact: screenshots
            condition: failed()
            continueOnError: true
          - task: PublishTestResults@2
            displayName: Publish Test Results
            condition: succeededOrFailed()
            inputs:
              codeCoverageTool: JUnit
              testRunTitle: Benchmarks ruby rspec test suite with in-browser
              testResultsFiles: "tmp/rspec.xml"

  - stage: Build
    displayName: Build and Push
    condition: and(succeeded(), eq(variables.isMain, 'true'))
    jobs:
      - job: BuildBase
        displayName: Build and Push Base
        condition: and(succeeded(), or(eq(variables['Build.Reason'], 'Schedule'), eq(variables.buildBaseImage, 'true')))
        steps:
          - task: Docker@2
            displayName: Login to ACR
            inputs:
              command: login
              containerRegistry: $(ACR_SERVICE_ENDPOINT_NAME)
          - task: Docker@2
            displayName: Build base image
            inputs:
              command: build
              containerRegistry: $(ACR_SERVICE_ENDPOINT_NAME)
              repository: $(CONTAINER_REPOSITORY)_builder
              buildContext: $(Build.Repository.LocalPath)
              Dockerfile: config/docker/builder/Dockerfile
              arguments: "--no-cache"
              tags: |
                $(tag)
                latest
          - task: Docker@2
            displayName: Push base image to ACR
            inputs:
              command: push
              containerRegistry: $(ACR_SERVICE_ENDPOINT_NAME)
              repository: $(CONTAINER_REPOSITORY)_builder
              tags: |
                $(tag)
                latest
          - task: Docker@2
            displayName: Logout of ACR
            inputs:
              command: logout
              containerRegistry: $(ACR_SERVICE_ENDPOINT_NAME)
      - job: Build
        displayName: Build and Push Image
        dependsOn: BuildBase
        condition: ne(variables['Build.Reason'], 'Schedule')
        steps:
          - task: Docker@2
            displayName: Login to ACR
            inputs:
              command: login
              containerRegistry: $(ACR_SERVICE_ENDPOINT_NAME)
          - task: Docker@2
            displayName: Docker build image
            inputs:
              command: build
              containerRegistry: $(ACR_SERVICE_ENDPOINT_NAME)
              repository: $(CONTAINER_REPOSITORY)
              buildContext: $(Build.Repository.LocalPath)
              Dockerfile: config/docker/Dockerfile
              tags: |
                $(tag)
                latest
              arguments: "--no-cache --build-arg COMMIT_SHA=$(Build.SourceVersion) --build-arg DOCKER_IMAGE_TAG=$(tag) --build-arg BUILDER_IMAGE=$(CONTAINER_REGISTRY_DOMAIN)/$(CONTAINER_REPOSITORY)_builder:latest"
          - task: Docker@2
            displayName: Docker push image to ACR
            inputs:
              command: push
              containerRegistry: $(ACR_SERVICE_ENDPOINT_NAME)
              repository: $(CONTAINER_REPOSITORY)
              tags: |
                $(tag)
                latest
          - task: Docker@2
            displayName: Logout of ACR
            inputs:
              command: logout
              containerRegistry: $(ACR_SERVICE_ENDPOINT_NAME)
  - stage: Staging
    dependsOn: Build
    condition: and(succeeded(), ne(variables['Build.Reason'], 'Schedule'))
    jobs:
      - deployment: Stage
        displayName: Deploy to Staging
        environment: Staging
        strategy:
          runOnce:
            deploy:
              steps:
                - task: AzureRMWebAppDeployment@4
                  displayName: Azure App Service Deploy
                  inputs:
                    appType: webAppContainer
                    ConnectedServiceName: $(azureSubscription)
                    WebAppName: $(AZURE_APP_SERVICE_NAME)
                    DockerNamespace: $(CONTAINER_REGISTRY_DOMAIN)
                    DockerRepository: $(CONTAINER_REPOSITORY)
                    DockerImageTag: $(tag)
                    SlotName: staging
  - stage: Production
    dependsOn: Staging
    condition: and(succeeded(), ne(variables['Build.Reason'], 'Schedule'))
    jobs:
      - deployment: Promote
        displayName: Promote to production
        environment: Production
        strategy:
          runOnce:
            # Deploying to a preview slot and then swapping, ensures that
            # the production container is ready before it receives traffic,
            # hopefully preventing downtime.
            deploy:
              steps:
                - task: AzureRMWebAppDeployment@4
                  displayName: Azure App Service Deploy
                  inputs:
                    appType: webAppContainer
                    ConnectedServiceName: $(azureSubscription)
                    WebAppName: $(AZURE_APP_SERVICE_NAME)
                    DockerNamespace: $(CONTAINER_REGISTRY_DOMAIN)
                    DockerRepository: $(CONTAINER_REPOSITORY)
                    DockerImageTag: $(tag)
                    SlotName: preview
            routeTraffic:
              steps:
                - task: AzureAppServiceManage@0
                  inputs:
                    azureSubscription: $(azureSubscription)
                    WebAppName: $(AZURE_APP_SERVICE_NAME)
                    ResourceGroupName: $(AZURE_RESOURCE_GROUP_NAME)
                    SourceSlot: preview
                    SwapWithProduction: true
