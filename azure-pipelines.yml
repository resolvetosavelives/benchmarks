# Schedule builds trigger the base image build step.
schedules:
  - cron: "0 0 * * *"
    displayName: Daily midnight build for base image
    branches:
      include:
        - main

# These parameters with hardcoded values are here to show the manual link
# between the pipeline and the resource created manually by the WHO azure admin.
# My goal is to expose them here to avoid burying them deep in terraform or ENV.
# These are not expected to be changeable (it likely won't work)
parameters:
  - name: containerRegistryServiceConnection
    displayName: Container Registry Service Connection Name
    type: string
    default: SC-IHRBENCHMARK-P-ACR
  - name: azureSubscription
    displayName: Azure Resource Manager Service Connection Name
    type: string
    default: SC-IHRBENCHMARK-P-WEU-RG01
  # Allow access to building the base image outside of the scheduled build.
  # This is useful when you change the base image and want to iterate on it.
  - name: buildBaseImage
    displayName: Build Docker Base Image
    type: boolean
    default: false

variables:
  # The variable group is created by terraform to hold pipeline info that is
  # generated by terraform and could potentially change on a future run.
  - group: pipeline-variable-group
  - name: DOCKER_BUILDKIT
    value: 1
  - name: tag
    value: $(build.buildId)
  - name: containerRegistry
    value: $(ACR_SERVICE_ENDPOINT_NAME)
  - name: azureSubscription
    value: ${{parameters.azureSubscription}}
  - name: isMain
    value: $[eq(variables['Build.SourceBranch'], 'refs/heads/main')]
  - name: buildBaseImage
    value: ${{ parameters.buildBaseImage }}
  - name: DATABASE_URL
    value: postgres://postgres:postgresPassword@localhost:5432/benchmarks_test

resources:
  containers:
    - container: postgres
      image: postgres:14-alpine
      env:
        POSTGRES_DB: benchmarks_test
        POSTGRES_USER: postgres
        POSTGRES_PASSWORD: postgresPassword
      ports:
        - "5432:5432"

stages:
  - stage: Test
    jobs:
      - job: Test
        displayName: Run CI Tests
        condition: ne(variables['Build.Reason'], 'Schedule')
        pool:
          # ubuntu-20.04 image includes most of what we need, cutting down on installs
          # https://github.com/actions/virtual-environments/blob/main/images/linux/Ubuntu2004-Readme.md
          vmImage: "ubuntu-20.04"
        services:
          postgres: postgres
        steps:
          - script: printenv
            displayName: printenv
          # - task: UseRubyVersion@0
          #   inputs:
          #     versionSpec: ">= 3.0"
          #     addToPath: true
          # - task: NodeTool@0
          #   inputs:
          #     versionSpec: "16.x"
          # - script: |
          #     bin/bundle config set --local path vendor/bundle && \
          #     bin/bundle config set --local deployment true && \
          #     bin/bundle install
          #   displayName: bundle install
          # - script: yarn install --frozen-lockfile --check-files
          #   displayName: yarn install
          # - task: CmdLine@2
          #   displayName: prepare test db
          #   env:
          #     DATABASE_URL: $(DATABASE_URL)
          #     RAILS_ENV: test
          #   inputs:
          #     script: bin/bundle exec rake db:schema:load db:seed
          # - task: CmdLine@2
          #   displayName: rake test:ci
          #   env:
          #     DATABASE_URL: $(DATABASE_URL)
          #     MINITEST_REPORTER: JUnitReporter
          #     RAILS_ENV: test
          #   inputs:
          #     script: bin/bundle exec rake test:ci
          # - task: PublishTestResults@2
          #   condition: succeededOrFailed()
          #   inputs:
          #     codeCoverageTool: JUnit
          #     testRunTitle: Benchmarks ruby rspec test suite with in-browser
          #     testResultsFiles: "**/TEST-*.xml"

  - stage: Build
    displayName: Build and Push
    condition: and(succeeded(), eq(variables.isMain, 'true'))
    jobs:
      - job: BuildBase
        displayName: Build and Push Base
        # temporarily build base image every time so we can ensure everything is working
        # condition: and(succeeded(), or(eq(variables['Build.Reason'], 'Schedule'), eq(variables.buildBaseImage, 'true')))
        steps:
          - task: Docker@2
            displayName: Login to ACR
            inputs:
              command: login
              containerRegistry: $(containerRegistry)
          - task: Docker@2
            displayName: Build base image
            inputs:
              command: build
              containerRegistry: $(containerRegistry)
              repository: $(CONTAINER_REPOSITORY)_builder
              buildContext: $(Build.Repository.LocalPath)
              Dockerfile: config/docker/builder/Dockerfile
              arguments: "--no-cache"
              tags: |
                $(tag)
                latest
          - task: Docker@2
            displayName: Push base image to ACR
            inputs:
              command: push
              containerRegistry: $(containerRegistry)
              repository: $(CONTAINER_REPOSITORY)_builder
              tags: |
                $(tag)
                latest
          - task: Docker@2
            displayName: Logout of ACR
            inputs:
              command: logout
              containerRegistry: $(containerRegistry)
      - job: Build
        displayName: Build and Push Image
        dependsOn: BuildBase
        condition: ne(variables['Build.Reason'], 'Schedule')
        steps:
          - task: Docker@2
            displayName: Login to ACR
            inputs:
              command: login
              containerRegistry: $(containerRegistry)
          - script: echo $(RAILS_MASTER_KEY) > config/master.key
            displayName: Write RAILS_MASTER_KEY to file config/master.key
          - task: Docker@2
            displayName: Docker build image
            inputs:
              command: build
              containerRegistry: $(containerRegistry)
              repository: $(CONTAINER_REPOSITORY)
              buildContext: $(Build.Repository.LocalPath)
              Dockerfile: config/docker/Dockerfile
              tags: |
                $(tag)
                latest
              arguments: "--secret id=RAILS_MASTER_KEY,src=config/master.key --no-cache --build-arg BUILDER_IMAGE=$(CONTAINER_REGISTRY_DOMAIN)/$(CONTAINER_REPOSITORY)_builder:latest"
          - script: rm config/master.key
            displayName: Delete RAILS_MASTER_KEY file config/master.key
          - task: Docker@2
            displayName: Docker push image to ACR
            inputs:
              command: push
              containerRegistry: $(containerRegistry)
              repository: $(CONTAINER_REPOSITORY)
              tags: |
                $(tag)
                latest
          - task: Docker@2
            displayName: Logout of ACR
            inputs:
              command: logout
              containerRegistry: $(containerRegistry)
  - stage: Staging
    dependsOn: Build
    condition: and(succeeded(), ne(variables['Build.Reason'], 'Schedule'))
    jobs:
      - deployment: Stage
        displayName: Deploy to Staging
        strategy:
          runOnce: #rolling, canary are the other strategies that are supported
            preDeploy:
              steps:
                - script: rake db:create
                  displayName: rake db:create
                  container: "$(CONTAINER_REGISTRY_DOMAIN)/$(CONTAINER_REPOSITORY):latest"
            deploy:
              steps:
                - task: AzureRMWebAppDeployment@4
                  displayName: Azure App Service Deploy
                  inputs:
                    appType: webAppContainer
                    ConnectedServiceName: $(azureSubscription)
                    WebAppName: $(AZURE_APP_SERVICE_NAME)
                    DockerNamespace: $(CONTAINER_REGISTRY_DOMAIN)
                    DockerRepository: $(CONTAINER_REPOSITORY)
                    DockerImageTag: $(tag)
          # - task: AzureWebAppContainer@1
          #   inputs:
          #     azureSubscription: $(azureSubscription)
          #     appName: $(AZURE_APP_SERVICE_NAME)
          #     imageName: $(CONTAINER_REGISTRY_DOMAIN)/$(CONTAINER_REPOSITORY):$(tag)
          #     deployToSlotOrASE: true
          #     ResourceGroupName: $(AZURE_RESOURCE_GROUP_NAME)
          #     slotName: staging
  - stage: Production
    dependsOn: Staging
    condition: and(succeeded(), ne(variables['Build.Reason'], 'Schedule'))
    jobs:
      - deployment: Promote
        displayName: Promote to production
        strategy:
          runOnce: #rolling, canary are the other strategies that are supported
            deploy:
              steps:
                - task: AzureAppServiceManage@0
                  inputs:
                    azureSubscription: $(azureSubscription)
                    WebAppName: $(AZURE_APP_SERVICE_NAME)
                    ResourceGroupName: $(AZURE_RESOURCE_GROUP_NAME)
                    SourceSlot: staging
                    SwapWithProduction: true
