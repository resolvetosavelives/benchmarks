# Schedule builds trigger the base image build step.
schedules:
  - cron: "0 0 * * *"
    displayName: Daily midnight build for base image
    branches:
      include:
        - main

# These parameters with hardcoded values are here to show the manual link
# between the pipeline and the resource created manually by the WHO azure admin.
# My goal is to expose them here to avoid burying them deep in terraform or ENV.
# These are not expected to be changeable (it likely won't work)
parameters:
  - name: azureSubscription
    displayName: AzureRM Service Connection Name
    type: string
    default: SC-IHRBENCHMARK-P-WEU-RG01
  # Allow access to building the base image outside of the scheduled build.
  # This is useful when you change the base image and want to iterate on it.
  - name: buildBaseImage
    displayName: Build Docker Base Image
    type: boolean
    default: false
  - name: runTerraform
    displayName: Run Terraform
    type: boolean
    default: true
  - name: terraformServiceConnection
    displayName: Terraform AzureRM Service Connection Name
    type: string
    default: SC-IHRBENCHMARK-MAIN-WEU-RG01

variables:
  # The variable group is created by terraform to hold pipeline info that is
  # generated by terraform and could potentially change on a future run.
  - group: pipeline-variable-group
  - group: pipeline-variables
  - name: DOCKER_BUILDKIT
    value: 1
  - name: tag
    value: $(build.buildId)
  - name: azureSubscription
    value: ${{parameters.azureSubscription}}
  - name: isMain
    value: $[eq(variables['Build.SourceBranch'], 'refs/heads/main')]
  - name: buildBaseImage
    value: ${{ parameters.buildBaseImage }}
  - name: builderImageName
    value: $(CONTAINER_REGISTRY_DOMAIN)/$(CONTAINER_REPOSITORY)_builder:latest
  - name: imageName
    value: $(CONTAINER_REGISTRY_DOMAIN)/$(CONTAINER_REPOSITORY):$(tag)
  - name: azureLocation
    value: westeurope
  - name: terraformServiceConnection
    value: ${{parameters.terraformServiceConnection}}

resources:
  containers:
    - container: postgres
      image: postgres:14-alpine
      env:
        POSTGRES_DB: benchmarks_test
        POSTGRES_USER: postgres
        POSTGRES_PASSWORD: postgresPassword
      ports:
        - "5432:5432"

stages:
  - stage: Test
    variables:
      CI: true
      DATABASE_URL: postgres://postgres:postgresPassword@localhost:5432/benchmarks_test
      RAILS_ENV: test
    jobs:
      - job: Test
        displayName: Run CI Tests
        condition: ne(variables['Build.Reason'], 'Schedule')
        pool:
          # ubuntu-20.04 image includes most of what we need, cutting down on installs
          # https://github.com/actions/virtual-environments/blob/main/images/linux/Ubuntu2004-Readme.md
          vmImage: "ubuntu-20.04"
        services:
          postgres: postgres
        steps:
          - script: printenv
            displayName: printenv
          # - task: UseRubyVersion@0
          #   inputs:
          #     versionSpec: ">= 3.0"
          #     addToPath: true
          # - task: NodeTool@0
          #   inputs:
          #     versionSpec: "16.x"
          # - script: |
          #     bin/bundle config set --local path vendor/bundle && \
          #     bin/bundle config set --local deployment true && \
          #     bin/bundle install
          #   displayName: bundle install
          # - script: yarn install --frozen-lockfile --check-files
          #   displayName: yarn install
          # - task: CmdLine@2
          #   displayName: prepare test db
          #   inputs:
          #     script: bin/bundle exec rake db:schema:load db:seed
          # - task: CmdLine@2
          #   # precompile assets to avoid timeouts during capybara tests
          #   displayName: precompile assets
          #   inputs:
          #     script: bin/bundle exec rails assets:precompile
          # - task: CmdLine@2
          #   displayName: rake spec:ci
          #   env:
          #     SPEC_OPTS: "--format progress --format RspecJunitFormatter --out tmp/rspec.xml"
          #   inputs:
          #     script: bin/bundle exec rake spec:ci
          # - publish: $(System.DefaultWorkingDirectory)/tmp/capybara
          #   displayName: Publish Failure Screenshot
          #   artifact: screenshots
          #   condition: failed()
          #   continueOnError: true
          # - task: PublishTestResults@2
          #   displayName: Publish Test Results
          #   condition: succeededOrFailed()
          #   inputs:
          #     codeCoverageTool: JUnit
          #     testRunTitle: Benchmarks ruby rspec test suite with in-browser
          #     testResultsFiles: "tmp/rspec.xml"
  - stage: Terraform
    # condition: eq(variables.runTerraform, 'true')
    variables:
      terraformDirectory: $(System.DefaultWorkingDirectory)/config/terraform/env/cloudcity-pipeline
      TF_VAR_organization_prefix: $(ORGANIZATION_PREFIX)
      AZDO_ORG_SERVICE_URL: $(System.CollectionUri)
    jobs:
    - job: Terraform
      continueOnError: false
      steps:
      - task: TerraformInstaller@0
        displayName: install
      - task: TerraformCLI@0
        displayName: terraform init
        inputs:
          command: init
          backendType: azurerm
          # Service connection to authorize backend access. Supports Subscription & Management Group Scope
          backendServiceArm: $(terraformServiceConnection)
          # Subscription id of the target backend. This can be used to specify the subscription when using Management Group scoped
          # Service connection or to override the subscription id defined in a Subscription scoped service connection
          # backendAzureRmSubscriptionId: 'my-backend-subscription-id'
          # create backend storage account if doesn't exist
          ensureBackend: true
          backendAzureRmResourceGroupName: $(TERRAFORM_RESOURCE_GROUP_NAME)
          # azure location shortname of the backend resource group and storage account
          backendAzureRmResourceGroupLocation: $(azureLocation)
          backendAzureRmStorageAccountName: $(TERRAFORM_STORAGE_ACCOUNT_NAME)
          # azure storage account sku, used when creating the storage account
          backendAzureRmStorageAccountSku: 'Standard_RAGRS'
          # azure blob container to store the state file
          backendAzureRmContainerName: $(TERRAFORM_CONTAINER_NAME)
          # azure blob file name
          backendAzureRmKey: terraform.tfstate
          workingDirectory: $(terraformDirectory)
      - task: TerraformCLI@0
        displayName: terraform validate
        inputs:
          command: validate
          environmentServiceName: $(azureSubscription)
          workingDirectory: $(terraformDirectory)
      - task: TerraformCLI@0
        displayName: terraform plan
        inputs:
          command: plan
          environmentServiceName: $(azureSubscription)
          commandOptions: '-out=$(terraformDirectory)/terraform.tfplan -detailed-exitcode'
          publishPlanResults: plan
          workingDirectory: $(terraformDirectory)
      # - task: TerraformCLI@0
      #   displayName: 'terraform apply'
      #   condition: and(succeeded(), eq(variables['TERRAFORM_PLAN_HAS_CHANGES'], 'true'))
      #   inputs:
      #     command: apply
      #     environmentServiceName: $(azureSubscription)
      #     commandOptions: '$(terraformDirectory)/terraform.tfplan'
      #     workingDirectory: $(terraformDirectory)
      - task: TerraformCLI@0
        displayName: 'terraform output'
        inputs:
          command: output
          environmentServiceName: $(azureSubscription)
          workingDirectory: $(terraformDirectory)
  - stage: Build
    displayName: Build and Push
    condition: and(succeeded(), eq(variables.isMain, 'true'))
    jobs:
      - job: BuildBase
        displayName: Build and Push Base
        condition: and(succeeded(), or(eq(variables['Build.Reason'], 'Schedule'), eq(variables.buildBaseImage, 'true')))
        steps:
          - task: Docker@2
            displayName: Login to ACR
            inputs:
              command: login
              containerRegistry: $(ACR_SERVICE_ENDPOINT_NAME)
          - task: Docker@2
            displayName: Build base image
            inputs:
              command: build
              containerRegistry: $(ACR_SERVICE_ENDPOINT_NAME)
              repository: $(CONTAINER_REPOSITORY)_builder
              buildContext: $(Build.Repository.LocalPath)
              Dockerfile: config/docker/builder/Dockerfile
              arguments: "--no-cache"
              tags: |
                $(tag)
                latest
          - task: Docker@2
            displayName: Push base image to ACR
            inputs:
              command: push
              containerRegistry: $(ACR_SERVICE_ENDPOINT_NAME)
              repository: $(CONTAINER_REPOSITORY)_builder
              tags: |
                $(tag)
                latest
          - task: Docker@2
            displayName: Logout of ACR
            inputs:
              command: logout
              containerRegistry: $(ACR_SERVICE_ENDPOINT_NAME)
      - job: Build
        displayName: Build and Push Image
        dependsOn: BuildBase
        condition: ne(variables['Build.Reason'], 'Schedule')
        steps:
          - task: Docker@2
            displayName: Login to ACR
            inputs:
              command: login
              containerRegistry: $(ACR_SERVICE_ENDPOINT_NAME)
          - task: Docker@2
            displayName: Docker build image
            inputs:
              command: build
              containerRegistry: $(ACR_SERVICE_ENDPOINT_NAME)
              repository: $(CONTAINER_REPOSITORY)
              buildContext: $(Build.Repository.LocalPath)
              Dockerfile: config/docker/Dockerfile
              tags: |
                $(tag)
                latest
              arguments: "--no-cache --build-arg COMMIT_SHA=$(Build.SourceVersion) --build-arg DOCKER_IMAGE_TAG=$(tag) --build-arg BUILDER_IMAGE=$(builderImageName)"
          - task: Docker@2
            displayName: Docker push image to ACR
            inputs:
              command: push
              containerRegistry: $(ACR_SERVICE_ENDPOINT_NAME)
              repository: $(CONTAINER_REPOSITORY)
              tags: |
                $(tag)
                latest
          - task: Docker@2
            displayName: Logout of ACR
            inputs:
              command: logout
              containerRegistry: $(ACR_SERVICE_ENDPOINT_NAME)
  - stage: Staging
    dependsOn: Build
    condition: and(succeeded(), ne(variables['Build.Reason'], 'Schedule'))
    jobs:
      - deployment: Stage
        displayName: Deploy to Staging
        environment: Staging
        strategy:
          runOnce:
            deploy:
              steps:
                - task: AzureAppServiceSettings@1
                  displayName: Azure App Service Settings
                  inputs:
                    azureSubscription: $(azureSubscription)
                    appName: $(APP_SERVICE_NAME)
                    slotName: staging
                    appSettings: |
                      [
                        {
                          "name": "RAILS_MASTER_KEY",
                          "value": "$(RAILS_MASTER_KEY)",
                          "slotSetting": true
                        },
                        {
                          "name": "DATABASE_URL",
                          "value": "$(STAGING_DATABASE_URL)",
                          "slotSetting": true
                        }
                      ]
                - task: AzureWebAppContainer@1
                  displayName: Azure App Service Deploy
                  inputs:
                    azureSubscription: $(azureSubscription)
                    appName: $(APP_SERVICE_NAME)
                    deployToSlotOrASE: true
                    slotName: staging
                    imageName: $(imageName)
  - stage: Production
    dependsOn: Staging
    condition: and(succeeded(), ne(variables['Build.Reason'], 'Schedule'))
    jobs:
      - deployment: Promote
        displayName: Promote to production
        environment: Production
        strategy:
          runOnce:
            # Deploying to a preview slot and then swapping, ensures that
            # the production container is ready before it receives traffic,
            # hopefully preventing downtime.
            deploy:
              steps:
                - task: AzureAppServiceSettings@1
                  displayName: Azure App Service Settings
                  inputs:
                    azureSubscription: $(azureSubscription)
                    appName: $(APP_SERVICE_NAME)
                    slotName: staging
                    appSettings: |
                      [
                        {
                          "name": "RAILS_MASTER_KEY",
                          "value": "$(RAILS_MASTER_KEY)",
                          "slotSetting": false
                        },
                        {
                          "name": "DATABASE_URL",
                          "value": "$(PRODUCTION_DATABASE_URL)",
                          "slotSetting": false
                        }
                      ]
                - task: AzureWebAppContainer@1
                  displayName: Azure App Service Deploy
                  inputs:
                    azureSubscription: $(azureSubscription)
                    appName: $(APP_SERVICE_NAME)
                    deployToSlotOrASE: true
                    slotName: preview
                    imageName: $(imageName)
            routeTraffic:
              steps:
                - task: AzureAppServiceManage@0
                  inputs:
                    azureSubscription: $(azureSubscription)
                    WebAppName: $(APP_SERVICE_NAME)
                    ResourceGroupName: $(RESOURCE_GROUP_NAME)
                    SourceSlot: preview
                    SwapWithProduction: true
